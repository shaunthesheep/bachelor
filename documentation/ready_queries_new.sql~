--most recent valid time value:
select vt[array_length(vt, 1):array_length(vt, 1)] from records_record;

--select rent date and return date YEAH!!!!!!!!!!!!!!!!!!NIE AKTUALNE
SELECT id, 
CASE WHEN array_length(tt, 1) = 1 
THEN to_char(CURRENT_DATE, 'MM/DD/YYYY')
ELSE rent_day(tt, vt) 
END AS rented,
CASE WHEN tt[array_length(tt, 1):array_length(tt, 1)] = ARRAY['0001-01-01']::date[]
THEN ''
ELSE to_char(unnest(tt[array_length(tt, 1):array_length(tt, 1)]), 'MM/DD/YYYY') END AS returned,
to_char(unnest(vt[array_length(vt, 1):array_length(vt, 1)]), 'MM/DD/YYYY') AS due
FROM records_record;


-- FUNCTIONS

--returns transaction time of rent start YEAH@!!!!!!!!!!!!!!!!!!
CREATE OR REPLACE FUNCTION rent_day(date[], int)
RETURNS varchar
AS
$$
DECLARE
	valid ALIAS FOR $1;
	period ALIAS FOR $2;
	len int;
	idx int;
BEGIN
	IF valid IS NULL THEN
		RETURN '';
	END IF;

	len = array_length(valid, 1);

	IF len = 1 OR len = period THEN
		RETURN to_char(unnest(valid[1]), 'MM/DD/YYYY');
	END IF;
	
	idx = len - period + 1;
	
RETURN to_char(unnest(valid[idx:idx]), 'MM/DD/YYYY');
END;
$$
LANGUAGE plpgsql 

--returns last value of array or null if record doeas not exist YEAH@!!!!!!!!!!!!!!!!!!
CREATE OR REPLACE FUNCTION get_day_or_null(date[])
RETURNS varchar
AS
$$
DECLARE
	the_array ALIAS FOR $1;
BEGIN
	IF the_array IS NULL THEN
		RETURN '';
	END IF;
RETURN to_char(unnest(the_array[array_length(the_array, 1):array_length(the_array, 1)]), 'MM/DD/YYYY');
END;
$$
LANGUAGE plpgsql 

-- select detailed info about items YEAH@!!!!!!!!!!!!!!!!!!
CREATE OR REPLACE FUNCTION item_details()
  RETURNS TABLE (
   id   	int
  ,name		varchar(128)
  ,model   	varchar(128)
  ,period 	int
  ,penalty	numeric(8,2)
  ,available	boolean
  ,rented	varchar(10)
  ,returned	varchar(10)
  ,due		varchar(10)
  ) AS
$func$
BEGIN

   RETURN QUERY
SELECT i.id AS id, i.name AS name, i.model AS model, i.period AS period, i.penalty AS penalty, i.availability AS available, 
	CASE WHEN array_length(r.tt, 1) = 1 THEN to_char(CURRENT_DATE, 'MM/DD/YYYY') ELSE rent_day(r.vt, i.period) END AS rented,
	CASE WHEN r.tt[array_length(r.tt, 1):array_length(r.tt, 1)] = ARRAY['0001-01-01']::date[] 
	       THEN '' ELSE get_day_or_null(r.tt)
	        END AS returned,
	get_day_or_null(r.vt) AS due
FROM items_item i LEFT OUTER JOIN records_record r  ON i.id = r.item_id;

END
$func$  LANGUAGE plpgsql;

-- select detailed info about items rented by particular person
CREATE OR REPLACE FUNCTION user_item_details(varchar(30))
  RETURNS TABLE (
  username	varchar(30)
  ,id   	int
  ,name		varchar(128)
  ,model   	varchar(128)
  ,period 	int
  ,penalty	numeric(8,2)
  ,available	boolean
  ,rented	varchar(10)
  ,returned	varchar(10)
  ,due		varchar(10)
  ) AS
$func$
DECLARE
	the_name ALIAS FOR $1;
BEGIN

   RETURN QUERY
SELECT au.username AS username, i.id AS id, i.name AS name, i.model AS model, i.period AS period, i.penalty AS penalty, i.availability AS available, 
	CASE WHEN array_length(r.tt, 1) = 1 THEN to_char(CURRENT_DATE, 'MM/DD/YYYY') ELSE rent_day(r.vt, i.period) END AS rented,
	CASE WHEN r.tt[array_length(r.tt, 1):array_length(r.tt, 1)] = ARRAY['0001-01-01']::date[] 
	       THEN '' ELSE get_day_or_null(r.tt)
	        END AS returned,
	get_day_or_null(r.vt) AS due
FROM items_item i LEFT OUTER JOIN records_record r  ON i.id = r.item_id JOIN auth_user au ON au.id = r.user_id
WHERE au.username LIKE the_name;

END
$func$  LANGUAGE plpgsql;



